在Node.js中，将应用程序的负载分配到单台机器上不同实例的最简单模式是通过使用集群（`cluster`）模块，它是核心库的一部分。

集群模块简化了相同应用的实例拷贝，并自动将传入的连接分配到它们之间。

主进程（`master process`）负责启动多个进程（工作进程`workers`），每个进程代表我们想要扩展的应用程序的一个实例。随后，每个进入的连接被分配到克隆的工作进程中，将负载分散在它们之间。

由于每个worker都是一个独立进程，你可以使用这种方法根据系统可用的CPU数量来创建工作者。使用这种方法，你可以轻松地让Node.js应用程序利用系统中的所有计算能力。

## 集群模块行为
在大多数系统中，集群模块使用显式的轮询负载均衡算法（`round-robin load balancing algorithm`）。此算法在主进程中使用，确保请求在所有工作节点之间均匀分布。除了Windows之外，所有平台默认启用轮询调度，可以通过设置变量 `cluster.schedulingPolicy` 并使用常量 `cluster.SCHED_RR`（轮询）或 `cluster.SCHED_NONE`（由操作系统处理）来全局修改。

> 轮询算法基于轮询方式在可用的服务器之间均匀分配负载。第一个请求转发到第一个服务器，第二个请求转发到列表中的下一个服务器，依此类推。当达到列表的末尾时，迭代从开始处重新开始。在 `cluster` 模块中，轮询逻辑比传统实现要智能一些。事实上，它增加了一些额外行为，旨在避免给定的工作进程过载。

当我们使用集群模块时，每个工作进程中对 `server.listen()` 的调用都会委托给主进程。这允许主进程接收所有传入的消息并将它们分配给工作进程池。集群模块使得这种委托过程对于大多数用例来说非常简单，但存在一些边缘情况，在这些情况下，在工作模块中调用 `server.listen()` 可能不会像你预期的那样工作：

1. `server.listen({fd})`: 如果一个工作进程使用特定的文件描述符进行监听，例如，通过调用 `server.listen({fd: 17})`，此操作可能会产生意外结果。文件描述符在进程级别进行映射，因此如果工作进程映射了一个文件描述符，这不会与主进程中的相同文件匹配。克服这种限制的一种方法是在主进程中创建文件描述符，然后将其传递给工作进程。这样，工作进程可以使用主进程已知描述符调用 `server.listen()`
2. `server.listen(handle)`：在工作进程中显式使用handle对象（`FileHandle`）监听将导致工作进程直接使用提供的句柄，而不是将操作委托给主进程
3. `server.listen(0)`：调用 `server.listen(0)` 通常会导致服务器监听随机端口。然而，在集群中，每个工作进程每次调用 `server.listen(0)` 时都会收到相同的“随机”端口。换句话说，端口只在第一次调用时是随机的；从第二次调用开始将是固定的。如果你希望每个工作进程监听不同的随机端口，你必须自己生成端口号

## cluster用法

```js
if (cluster.isPrimary) {
    cluster.fork()
} else {
    // application
}
```
记住，每个worker都是一个不同的Node.js进程，拥有自己的事件循环、内存空间和已加载的模块，这一点很重要。

在底层，`cluster.fork()` 函数使用 `child_process.fork()` API，因此，我们也在主进程和工作者进程之间有一个通信通道可用。工作进程可以通过变量 `cluster.workers` 访问，所以向所有这些进程广播消息就像运行以下代码行一样简单：

```js
Object.values(cluster.workers).forEach(worker => worker.send('ping from master')
```

因为工作进程都是独立的，所以可以根据程序的需求进行终止或重新启动，而不会影响其他工作进程。只要还有工作进程存活，服务器将继续接受连接。如果所有工作进程都已死亡，现有连接将被断开，新连接将被拒绝。Nodejs不会自动管理工作进程的数量；然而，根据自身需求管理工作进程池是应用程序的责任。

通过启动同一应用程序的多个实例，我们正在创建一个冗余系统，这意味着如果其中一个实例因任何原因而关闭，我们仍然有其他实例准备提供服务。

## Zero downtime
当我们要向生产服务器发布新版本时，Node.js应用程序可能也需要重启。因此，在这种情况下，拥有多个实例可以帮助保持我们应用程序的可用性。

当我们需要有意重启应用程序以更新它时，应用程序在重启期间有一个小窗口无法处理请求。这在我们更新个人博客时可能是可以接受的，但对于有服务级别协议（SLA）的专业应用程序，或者作为持续交付过程的一部分经常更新的应用程序来说，这甚至不是一个选项。解决方案是实现零停机时间重启，即在不影响其可用性的情况下更新应用程序的代码。

使用集群模块，这再次是一个相对简单的任务：模式涉及逐个重启工作节点。这样，剩余的工作节点可以继续运行并维护应用程序的服务可用。

## 工具
推荐使用 [pm2](https://pm2.keymetrics.io/) 工具对cluster进行管理

2024年11月10日10:06:36