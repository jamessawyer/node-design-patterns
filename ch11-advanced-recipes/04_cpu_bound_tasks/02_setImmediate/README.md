正如我们所见，在保持应用程序响应性的同时运行CPU密集型任务并不复杂；只需使用setImmediate()来安排算法的下一步在任意挂起的I/O之后运行。

然而，这并不是从效率角度来说最好的方案。事实上，推迟一个任务会引入一个小的开销，而这个开销乘以算法必须运行的步骤总数，可能会对总体运行时间产生重大影响。

这通常是我们运行CPU密集型任务时最不希望看到的情况。缓解这个问题的可能解决方案是在经过一定步骤之后再使用setImmediate()——而不是在每一步都使用它——但即便如此，这仍然不能解决问题的根源。

此外，如果每一步运行时间都很长，这种技术效果并不好。在这种情况下，实际上，事件循环会失去响应性，整个应用开始出现卡顿，这在生产环境中是不理想的。

请注意，这并不意味着我们刚刚看到的技巧应该不惜一切代价避免。在某些情况下，如果同步任务偶尔执行且运行时间不长，使用setImmediate()来交错其执行有时是避免阻塞事件循环最简单最有效的方法。😎

🚨请注意，process.nextTick() 不能用于交错执行长时间运行的任务。正如我们在第三章“回调和事件”中看到的，nextTick() 将任务安排在所有挂起的I/O之前运行，这可能导致在重复调用的情况下I/O饥饿。你可以通过在之前的示例中将 setImmediate() 替换为 process.nextTick() 来自行验证这一点。