自Node 10.5.0以来，我们有一个新的机制来在主事件循环之外运行CPU密集型算法，称为工作线程。工作线程可以看作是 `child_process.fork()` 的一个轻量级替代品，并附带一些额外的好处。与进程相比，工作线程具有更小的内存占用和更快的启动时间，因为它们在主进程中运行，但位于不同的线程内。

尽管工作线程基于真实线程，但它们不支持像Java或Python等其他语言所支持的深度同步和共享功能。这是因为JavaScript是一种单线程语言，它没有内置机制来同步多个线程对变量的访问。带有线程的JavaScript那就不是JavaScript了🤣。在不实际改变语言的情况下，将线程的所有优点引入Node.js的解决方案是工作线程。

工作线程本质上是不与主应用程序线程共享任何内容的线程；它们在自己的V8实例中运行，拥有独立的Node.js运行时和事件循环。

与主线程的通信可以通过基于消息的通信通道、`ArrayBuffer` 对象的传输以及使用由用户管理的同步（通常借助 `Atomics`）的 `SharedArrayBuffer` 对象来实现。

这种将工作线程与主线程隔离的广泛程度保护了JS语言的完整性。同时，基本的通信设施和数据共享能力对于99%的使用场景来说已经足够。

想要更多了解worker thread可以阅读下面文章：

- [ES proposal: Shared memory and atomics](https://2ality.com/2017/01/shared-array-buffer.html)