先产生随机数据：
```
node populateDb.mjs
```

Request Batching pattern（请求批处理模式） 对高负载，慢API的场景效果显著；

Cache pattern（缓存模式）当请求数量较多且持续时间较长时，使用缓存相对于批处理的优势将更加明显。
我们必须记住，在实际应用程序中，我们可能希望使用更高级的缓存失效技术和存储机制。这是必要的，原因如下：
1. 大量的缓存值很容易消耗大量内存。在这种情况下，可以应用最近最少使用（`LRU`）或先进先出（`FIFO`）策略来保持恒定的内存利用率
2. 当应用程序分布在多个进程中时，将缓存保存在内存中可能会在每个服务器实例中产生不同的结果。如果我们正在实现的特定应用程序不希望这样做，那么解决方案是为缓存使用共享存储。这也比简单的内存解决方案性能更高，因为缓存是跨多个实例共享的。流行的缓存解决方案包括 `Redis` 和  `Memcached`
3. 与定时过期相比，手动缓存失效（例如，当相关的非缓存值发生变化时）可以启用更长的缓存，同时提供更多最新的数据，但是，当然，它的管理要复杂得多。我们不要忘记Phil Karlton （Netscape、Silicon Graphics等公司的首席工程师）的名言：“在计算机科学中只有两件困难的事情：缓存无效和命名。”

